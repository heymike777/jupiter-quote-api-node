/* tslint:disable */
/* eslint-disable */
/**
 * Jupiter API v6
 * The core of [jup.ag](https://jup.ag). Easily get a quote and swap through Jupiter API.  ### Rate Limit We update our rate limit from time to time depending on the load of our servers. We recommend running your own instance of the API if you want to have high rate limit, here to learn how to run the [self-hosted API](https://station.jup.ag/docs/apis/self-hosted).  ### API Wrapper - Typescript [@jup-ag/api](https://github.com/jup-ag/jupiter-quote-api-node)  ### Data types - Public keys are base58 encoded strings - raw data such as Vec<u8\\> are base64 encoded strings 
 *
 * The version of the OpenAPI document: 6.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { AggregatorQuoteResponse } from './AggregatorQuoteResponse';
import {
    AggregatorQuoteResponseFromJSON,
    AggregatorQuoteResponseFromJSONTyped,
    AggregatorQuoteResponseToJSON,
} from './AggregatorQuoteResponse';
import type { AggregatorSwapRequestComputeUnitPriceMicroLamports } from './AggregatorSwapRequestComputeUnitPriceMicroLamports';
import {
    AggregatorSwapRequestComputeUnitPriceMicroLamportsFromJSON,
    AggregatorSwapRequestComputeUnitPriceMicroLamportsFromJSONTyped,
    AggregatorSwapRequestComputeUnitPriceMicroLamportsToJSON,
} from './AggregatorSwapRequestComputeUnitPriceMicroLamports';
import type { AggregatorSwapRequestPrioritizationFeeLamports } from './AggregatorSwapRequestPrioritizationFeeLamports';
import {
    AggregatorSwapRequestPrioritizationFeeLamportsFromJSON,
    AggregatorSwapRequestPrioritizationFeeLamportsFromJSONTyped,
    AggregatorSwapRequestPrioritizationFeeLamportsToJSON,
} from './AggregatorSwapRequestPrioritizationFeeLamports';
import type { DynamicSlippageSettings } from './DynamicSlippageSettings';
import {
    DynamicSlippageSettingsFromJSON,
    DynamicSlippageSettingsFromJSONTyped,
    DynamicSlippageSettingsToJSON,
} from './DynamicSlippageSettings';
import type { KeyedUiAccount } from './KeyedUiAccount';
import {
    KeyedUiAccountFromJSON,
    KeyedUiAccountFromJSONTyped,
    KeyedUiAccountToJSON,
} from './KeyedUiAccount';

/**
 * 
 * @export
 * @interface AggregatorSwapRequest
 */
export interface AggregatorSwapRequest {
    /**
     * The user public key.
     * @type {string}
     * @memberof AggregatorSwapRequest
     */
    userPublicKey: string;
    /**
     * 
     * @type {AggregatorQuoteResponse}
     * @memberof AggregatorSwapRequest
     */
    quoteResponse: AggregatorQuoteResponse;
    /**
     * Default is true. If true, will automatically wrap/unwrap SOL. If false, it will use wSOL token account.  Will be ignored if `destinationTokenAccount` is set because the `destinationTokenAccount` may belong to a different user that we have no authority to close.
     * @type {boolean}
     * @memberof AggregatorSwapRequest
     */
    wrapAndUnwrapSol?: boolean;
    /**
     * Default is true. If true, will use the optimized wrapped SOL token account. If false, it will use the normal wrapped SOL token account.
     * @type {boolean}
     * @memberof AggregatorSwapRequest
     */
    allowOptimizedWrappedSolTokenAccount?: boolean;
    /**
     * Fee token account, same as the output token for ExactIn and as the input token for ExactOut, it is derived using the seeds = ["referral_ata", referral_account, mint] and the `REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3` referral contract (only pass in if you set a feeBps and make sure that the feeAccount has been created).
     * @type {string}
     * @memberof AggregatorSwapRequest
     */
    feeAccount?: string;
    /**
     * Public key of the token account that will be used to receive the token out of the swap. If not provided, the user's ATA will be used. If provided, we assume that the token account is already initialized.
     * @type {string}
     * @memberof AggregatorSwapRequest
     */
    destinationTokenAccount?: string;
    /**
     * 
     * @type {string}
     * @memberof AggregatorSwapRequest
     */
    trackingAccount?: string;
    /**
     * 
     * @type {AggregatorSwapRequestComputeUnitPriceMicroLamports}
     * @memberof AggregatorSwapRequest
     */
    computeUnitPriceMicroLamports?: AggregatorSwapRequestComputeUnitPriceMicroLamports;
    /**
     * 
     * @type {AggregatorSwapRequestPrioritizationFeeLamports}
     * @memberof AggregatorSwapRequest
     */
    prioritizationFeeLamports?: AggregatorSwapRequestPrioritizationFeeLamports;
    /**
     * When enabled, it will do a swap simulation to get the compute unit used and set it in ComputeBudget's compute unit limit. This will increase latency slightly since there will be one extra RPC call to simulate this. Default is `false`.
     * @type {boolean}
     * @memberof AggregatorSwapRequest
     */
    dynamicComputeUnitLimit?: boolean;
    /**
     * Default is false. Request a legacy transaction rather than the default versioned transaction, needs to be paired with a quote using asLegacyTransaction otherwise the transaction might be too large.
     * @type {boolean}
     * @memberof AggregatorSwapRequest
     */
    asLegacyTransaction?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AggregatorSwapRequest
     */
    useSharedAccounts?: boolean;
    /**
     * Default is false. This is useful when the instruction before the swap has a transfer that increases the input token amount. Then, the swap will just use the difference between the token ledger token amount and post token amount.
     * @type {boolean}
     * @memberof AggregatorSwapRequest
     */
    useTokenLedger?: boolean;
    /**
     * When enabled, it will not do any rpc calls check on user's accounts. Enable it only when you already setup all the accounts needed for the trasaction, like wrapping or unwrapping sol, destination account is already created.
     * @type {boolean}
     * @memberof AggregatorSwapRequest
     */
    skipUserAccountsRpcCalls?: boolean;
    /**
     * 
     * @type {Array<KeyedUiAccount>}
     * @memberof AggregatorSwapRequest
     */
    keyedUiAccounts?: Array<KeyedUiAccount>;
    /**
     * The program authority id [0;7], load balanced across the available set by default
     * @type {number}
     * @memberof AggregatorSwapRequest
     */
    programAuthorityId?: number;
    /**
     * 
     * @type {DynamicSlippageSettings}
     * @memberof AggregatorSwapRequest
     */
    dynamicSlippage?: DynamicSlippageSettings;
}

/**
 * Check if a given object implements the AggregatorSwapRequest interface.
 */
export function instanceOfAggregatorSwapRequest(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "userPublicKey" in value;
    isInstance = isInstance && "quoteResponse" in value;

    return isInstance;
}

export function AggregatorSwapRequestFromJSON(json: any): AggregatorSwapRequest {
    return AggregatorSwapRequestFromJSONTyped(json, false);
}

export function AggregatorSwapRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): AggregatorSwapRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'userPublicKey': json['userPublicKey'],
        'quoteResponse': AggregatorQuoteResponseFromJSON(json['quoteResponse']),
        'wrapAndUnwrapSol': !exists(json, 'wrapAndUnwrapSol') ? undefined : json['wrapAndUnwrapSol'],
        'allowOptimizedWrappedSolTokenAccount': !exists(json, 'allowOptimizedWrappedSolTokenAccount') ? undefined : json['allowOptimizedWrappedSolTokenAccount'],
        'feeAccount': !exists(json, 'feeAccount') ? undefined : json['feeAccount'],
        'destinationTokenAccount': !exists(json, 'destinationTokenAccount') ? undefined : json['destinationTokenAccount'],
        'trackingAccount': !exists(json, 'trackingAccount') ? undefined : json['trackingAccount'],
        'computeUnitPriceMicroLamports': !exists(json, 'computeUnitPriceMicroLamports') ? undefined : AggregatorSwapRequestComputeUnitPriceMicroLamportsFromJSON(json['computeUnitPriceMicroLamports']),
        'prioritizationFeeLamports': !exists(json, 'prioritizationFeeLamports') ? undefined : AggregatorSwapRequestPrioritizationFeeLamportsFromJSON(json['prioritizationFeeLamports']),
        'dynamicComputeUnitLimit': !exists(json, 'dynamicComputeUnitLimit') ? undefined : json['dynamicComputeUnitLimit'],
        'asLegacyTransaction': !exists(json, 'asLegacyTransaction') ? undefined : json['asLegacyTransaction'],
        'useSharedAccounts': !exists(json, 'useSharedAccounts') ? undefined : json['useSharedAccounts'],
        'useTokenLedger': !exists(json, 'useTokenLedger') ? undefined : json['useTokenLedger'],
        'skipUserAccountsRpcCalls': !exists(json, 'skipUserAccountsRpcCalls') ? undefined : json['skipUserAccountsRpcCalls'],
        'keyedUiAccounts': !exists(json, 'keyedUiAccounts') ? undefined : ((json['keyedUiAccounts'] as Array<any>).map(KeyedUiAccountFromJSON)),
        'programAuthorityId': !exists(json, 'programAuthorityId') ? undefined : json['programAuthorityId'],
        'dynamicSlippage': !exists(json, 'dynamicSlippage') ? undefined : DynamicSlippageSettingsFromJSON(json['dynamicSlippage']),
    };
}

export function AggregatorSwapRequestToJSON(value?: AggregatorSwapRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'userPublicKey': value.userPublicKey,
        'quoteResponse': AggregatorQuoteResponseToJSON(value.quoteResponse),
        'wrapAndUnwrapSol': value.wrapAndUnwrapSol,
        'allowOptimizedWrappedSolTokenAccount': value.allowOptimizedWrappedSolTokenAccount,
        'feeAccount': value.feeAccount,
        'destinationTokenAccount': value.destinationTokenAccount,
        'trackingAccount': value.trackingAccount,
        'computeUnitPriceMicroLamports': AggregatorSwapRequestComputeUnitPriceMicroLamportsToJSON(value.computeUnitPriceMicroLamports),
        'prioritizationFeeLamports': AggregatorSwapRequestPrioritizationFeeLamportsToJSON(value.prioritizationFeeLamports),
        'dynamicComputeUnitLimit': value.dynamicComputeUnitLimit,
        'asLegacyTransaction': value.asLegacyTransaction,
        'useSharedAccounts': value.useSharedAccounts,
        'useTokenLedger': value.useTokenLedger,
        'skipUserAccountsRpcCalls': value.skipUserAccountsRpcCalls,
        'keyedUiAccounts': value.keyedUiAccounts === undefined ? undefined : ((value.keyedUiAccounts as Array<any>).map(KeyedUiAccountToJSON)),
        'programAuthorityId': value.programAuthorityId,
        'dynamicSlippage': DynamicSlippageSettingsToJSON(value.dynamicSlippage),
    };
}

